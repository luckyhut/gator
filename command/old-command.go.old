package command

import (
	"context"
	"database/sql"
	"encoding/xml"
	"errors"
	"fmt"
	"github.com/google/uuid"
	"github.com/luckyhut/gator/config"
	"github.com/luckyhut/gator/database"
	"github.com/luckyhut/gator/rss"
	"html"
	"io"
	"net/http"
	"time"
)

func HandlerAgg(s *State, cmd Command) error {
	err := scrapeFeeds(s, cmd)
	if err != nil {
		errors.New("Error registering site")
	}
	return nil
}

func scrapeFeeds(s *State, cmd Command) error {
	if len(cmd.Args) < 1 {
		return errors.New("Not enough arguments")
	}
	ctx := context.Background()
	duration, err := time.ParseDuration(cmd.Args[0])
	if err != nil {
		return errors.New("Error parsing duration")
	}

	fmt.Println("Collecting feeds every", duration)

	ticker := time.NewTicker(duration)
	defer ticker.Stop()

	for ; ; <-ticker.C {
		nextFeed, err := s.Db.GetNextFeedToFetch(ctx)
		if err != nil {
			return errors.New("Error getting next feed from database")
		}

		curTime := sql.NullTime{
			Time:  time.Now(),
			Valid: true,
		}
		params := database.MarkFeedFetchedParams{
			ID:            nextFeed.ID,
			LastFetchedAt: curTime,
		}
		s.Db.MarkFeedFetched(ctx, params)

		feed, err := fetchFeed(ctx, nextFeed.Url.String)
		if err != nil {
			return err
		}

		for i := 0; i < len(feed.Channel.Item); i++ {
			fmt.Println(feed.Channel.Item[i].Title)
		}
	}
	return nil
}

func fetchFeed(ctx context.Context, feedURL string) (*rss.RSSFeed, error) {
	// make an http request and client
	req, err := http.NewRequestWithContext(ctx, "GET", feedURL, nil)
	if err != nil {
		return nil, errors.New("Unable to get a request")
	}
	client := &http.Client{}

	// set header, run request
	req.Header.Set("User-Agent", "gator")
	resp, err := client.Do(req)
	if err != nil {
		return nil, errors.New("Error running HTTP request")
	}
	defer resp.Body.Close()

	// use xml.Unmarshal to fit the response in a struct
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, errors.New("Error reading response body")
	}

	// xml.Unmarshal (works the same as json.Unmarshal)
	var feed rss.RSSFeed
	err = xml.Unmarshal(body, &feed)
	fmt.Println(feed)
	if err != nil {
		return nil, errors.New("Error unmarshaling xml data")
	}

	unescapeHtml(&feed)

	return &feed, nil
}

func unescapeHtml(feed *rss.RSSFeed) {
	feed.Channel.Title = html.UnescapeString(feed.Channel.Title)
	feed.Channel.Description = html.UnescapeString(feed.Channel.Description)
	for i := range feed.Channel.Item {
		feed.Channel.Item[i].Title = html.UnescapeString(feed.Channel.Item[i].Title)
		feed.Channel.Item[i].Title = html.UnescapeString(feed.Channel.Item[i].Title)
	}
}

func HandlerAddFeed(s *State, cmd Command, user database.User) error {
	if len(cmd.Args) < 2 {
		return errors.New("Must include a name and url with this command")
	}

	feedUuid := uuid.New()
	curTime := time.Now()
	dbContext := context.Background()
	name := sql.NullString{String: cmd.Args[0], Valid: true}
	url := sql.NullString{String: cmd.Args[1], Valid: true}

	userUuid := uuid.NullUUID{UUID: user.ID, Valid: true}

	params := database.CreateFeedParams{
		ID:        feedUuid,
		CreatedAt: curTime,
		UpdatedAt: curTime,
		Name:      name,
		Url:       url,
		UserID:    userUuid,
	}

	// run createfeed
	s.Db.CreateFeed(dbContext, params)

	feed_id, err := s.Db.GetFeed(dbContext, url)
	if err != nil {
		return errors.New("Error getting feed from database")
	}

	feedFollowsUuid := uuid.New()
	feedFollowParams := database.CreateFeedFollowParams{
		ID:        feedFollowsUuid,
		CreatedAt: curTime,
		UpdatedAt: curTime,
		UserID:    user.ID,
		FeedID:    feed_id,
	}

	s.Db.CreateFeedFollow(dbContext, feedFollowParams)

	return nil
}

func HandlerFeeds(s *State, cmd Command) error {
	dbContext := context.Background()
	result, err := s.Db.GetAllFeeds(dbContext)
	if err != nil {
		return errors.New("Unable to get list of feeds from database")
	}
	fmt.Println(result)

	return nil
}

func HandlerFollow(s *State, cmd Command, user database.User) error {
	if len(cmd.Args) == 0 {
		return errors.New("Must include arguments with command")
	}
	dbContext := context.Background()

	// id
	feedFollowUuid := uuid.New()

	// updated_at, created_at
	curTime := time.Now()

	// feed_id
	url := sql.NullString{String: cmd.Args[0], Valid: true}
	feed_id, err := s.Db.GetFeed(dbContext, url) // feed_id
	if err != nil {
		return errors.New("Error getting feed from database")
	}

	params := database.CreateFeedFollowParams{
		ID:        feedFollowUuid,
		CreatedAt: curTime,
		UpdatedAt: curTime,
		UserID:    user.ID,
		FeedID:    feed_id,
	}

	err = s.Db.CreateFeedFollow(dbContext, params)
	if err != nil {
		return errors.New("Could not create FeedFollow record")
	}

	return nil
}

func HandlerUnfollow(s *State, cmd Command, user database.User) error {
	dbContext := context.Background()
	url := sql.NullString{String: cmd.Args[0], Valid: true}
	feed_id, err := s.Db.GetFeed(dbContext, url) // feed_id
	if err != nil {
		return errors.New("Error getting feed from database")
	}

	params := database.UnfollowParams{
		UserID: user.ID,
		FeedID: feed_id,
	}

	s.Db.Unfollow(dbContext, params)
	return nil
}

func HandlerFollowing(s *State, cmd Command, user database.User) error {
	// get user id
	dbContext := context.Background()

	// get list of follows
	result, err := s.Db.GetFeedFollowsForUser(dbContext, user.ID)
	if err != nil {
		return errors.New("Unable to get list of feeds from database")
	}

	if len(result) == 0 {
		return nil
	}

	for i := 0; i < len(result); i++ {
		fmt.Print("* ", result[i].FeedName.String, "\n")
	}

	return nil
}

func MiddlewareLoggedIn(handler func(s *State, cmd Command, user database.User) error) func(*State, Command) error {
	return func(s *State, cmd Command) error {
		user, err := s.Db.GetUser(context.Background(), s.Config.CurrentUserName)
		if err != nil {
			return errors.New("User is not registered")
		}
		return handler(s, cmd, user)
	}
}
